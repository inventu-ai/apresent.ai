import { useEffect, useState, useMemo } from "react";
import { useIsMobile } from "@/hooks/use-mobile";
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  type DragEndEvent,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from "@dnd-kit/sortable";
import { OutlineItem } from "./OutlineItem";
import { Plus } from "lucide-react";
import { usePresentationState } from "@/states/presentation-state";
import { Skeleton } from "@/components/ui/skeleton";
import { useTranslation } from "@/contexts/LanguageContext";

interface OutlineItemType {
  id: string;
  title: string;
  isNew?: boolean;
}

export function OutlineList() {
  const {
    outline: initialItems,
    setOutline,
    numSlides,
    isGeneratingOutline,
  } = usePresentationState();
  const { t } = useTranslation();
  const isMobile = useIsMobile();

  const [items, setItems] = useState<OutlineItemType[]>(
    initialItems.map((title, index) => ({
      id: (index + 1).toString(),
      title,
    })),
  );

  useEffect(() => {

    // Preserve isNew property when updating from initialItems
    setItems(prevItems => {
      const newItems = initialItems.map((title, index) => {
        const id = (index + 1).toString();
        // Check if this item already exists and has isNew property
        const existingItem = prevItems.find(item => item.id === id);
        return {
          id,
          title,
          isNew: existingItem?.isNew || false
        };
      });

      return newItems;
    });
  }, [initialItems]);

  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    }),
  );

  function handleDragEnd(event: DragEndEvent) {
    const { active, over } = event;

    if (over && active.id !== over.id) {
      setItems((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        const newItems = arrayMove(items, oldIndex, newIndex);
        // Update the outline in the store
        setOutline(newItems.map((item) => item.title));
        return newItems;
      });
    }
  }

  const handleTitleChange = (id: string, newTitle: string) => {
    setItems((items) => {
      const newItems = items.map((item) =>
        item.id === id ? { ...item, title: newTitle } : item,
      );

      // Update the outline in the store
      setOutline(newItems.map((item) => item.title));
      return newItems;
    });
  };

  const handleAddCard = () => {
    const newId =
      items.length > 0
        ? (Math.max(...items.map((item) => parseInt(item.id))) + 1).toString()
        : "1";
    const newItems = [...items, { id: newId, title: "New Card", isNew: true }];
    
    setItems(newItems);
    // Update the outline in the store
    setOutline(newItems.map((item) => item.title));
  };

  const handleDeleteCard = (id: string) => {
    setItems((items) => {
      const newItems = items.filter((item) => item.id !== id);
      // Update the outline in the store
      setOutline(newItems.map((item) => item.title));
      return newItems;
    });
  };

  const content = useMemo(() => {
    const totalSlides = numSlides;
    const loadedCount = items.length;
    const remainingCount = Math.max(0, totalSlides - loadedCount);

    return (
      <DndContext
        sensors={sensors}
        collisionDetection={closestCenter}
        onDragEnd={handleDragEnd}
      >
        <SortableContext items={items} strategy={verticalListSortingStrategy}>
          <div className="space-y-2">
            {items.map((item, index) => (
              <OutlineItem
                key={item.id}
                id={item.id}
                index={index + 1}
                title={item.title}
                isNew={item.isNew}
                onTitleChange={(id, newTitle) => {
                  // If the title has been generated by AI, mark it as not new anymore
                  if (item.isNew && newTitle !== item.title && newTitle !== "New Card") {
                    const updatedItems = items.map(i => 
                      i.id === id ? { ...i, isNew: false } : i
                    );
                    setItems(updatedItems);
                  }
                  handleTitleChange(id, newTitle);
                }}
                onDelete={handleDeleteCard}
              />
            ))}
          </div>
        </SortableContext>
        {isGeneratingOutline &&
          Array.from({ length: remainingCount }).map((_, index) => (
            <Skeleton key={`skeleton-${index}`} className="h-16 w-full" />
          ))}
      </DndContext>
    );
  }, [
    items,
    numSlides,
    isGeneratingOutline,
    sensors,
    handleDragEnd,
    handleTitleChange,
    handleDeleteCard,
  ]);

  return (
    <div className="space-y-4">
      <div className={`flex items-center ${isMobile ? "justify-center" : "justify-between"}`}>
        <h2 className="text-sm text-foreground">{t.presentation.outline}</h2>
        {isGeneratingOutline && (
          <span className="animate-pulse text-xs text-muted-foreground">
            {t.presentation.generatingOutline}
          </span>
        )}
      </div>

      {content}

      <button
        onClick={handleAddCard}
        disabled={isGeneratingOutline}
        className="flex w-full items-center justify-center gap-2 rounded-md bg-muted/50 py-3 text-muted-foreground transition-colors hover:bg-muted disabled:opacity-50"
      >
        <Plus size={20} />
        {t.presentation.addCard}
      </button>

      <div className={`flex ${isMobile ? "justify-center" : "justify-between"} text-sm text-muted-foreground`}>
        <span>{items.length} {t.presentation.cardsTotal}</span>
        <span>
          {items.reduce((acc, item) => acc + item.title.length, 0)}/20000
        </span>
      </div>
    </div>
  );
}
